# How we use GitHub (and Git in general)

We use Git for version controlling our code and GitHub for hosting our repositories, running CI/CD tasks and managing pull requests, issues and code reviews. All code must be stored on GitHub. [Here is a guide for learning how to use git](https://rogerdudler.github.io/git-guide/).

## Teams

By default, members of our GitHub organization can't access any repositories. Instead, access is limited to teams within the organization. Each team relates to a project or client. For example, all repositories related to Mikkeller are part of the Mikkeller team.

To gain access to these repositories, you can ask to join the team, via the team overview found [here](https://github.com/orgs/Kvalifik/teams).

If you work more than 15 hours a week as a developer at Kvalifik, then you should be an owner of the organization, which gives you access to all repositories.

All interns should be members of the 'Interns' team granting them access to a limited subset of repositories.

## Branches

We use Gitflow as our branching strategy. Read more about it [here](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow).
Each repository has a default branch. This should be set to a branch named `staging`, and should represent the state of the staging environment of the application (called `develop` in the Gitflow documentation).
Each repository should also have a branch called `production`, which stores our production code (called `main` in the Gitflow documentation).
Each feature branch should have the name `feature/[issue-id]-[title]` corresponding to the Github issue ID and the title of the issue. _You may only push to a feature branch, never directly to staging nor production_.

> Note: Some Shopify projects (notably shop.mikkeller.dk) use a three-tier infrastructure of development-staging-production

### Tip for working on a new task that depends on a PR that isn't merged yet
Often you will have just finished work on 1 task and set the PR ready for review. While you await review, you will start work on the "next" task, that needs the code from your un-merged PR.

You will typically just create your new branch from the un-merged one and do your work.

When you then create the second PR, edit it's base to the older PR.


**That way you gain 2 advantages:**
1. The reviewer of this PR doesn't accidentally review the code from the earlier PR
2. You don't have merge conflicts when either of these are merged to the trunk

The only thing you need to be careful about is, that the earlier PR is merged *before* this new one. Otherwise this PRs code diff will show up as diff in the earlier one.
Merging the earlier one first and deleting the branch will cause this PR to automatically resolve it's base branch to staging, meaning everthing will work smoothly :-)

We recommend adding a note on the 2nd PR, so that others are aware of this special case.
## Issues

We use Github issues to connect tasks to pull requests and to easily work on tasks through the [Kvalifik CLI](https://github.com/Kvalifik/Kvalifik-CLI). The issues are populated through Forecast by Forecast's Github integration.

## Pull Requests

We use Github pull requests to manage pending code changes. Each pull request should be linked to the issue that it solves, and should always go from a feature branch to the `staging` branch. It is also possible to make a pull request from the `staging` branch to the `production` branch to launch new features. _We never merge a feature branch directly into the production branch._ Pull requests are automatically generated by the Kvalifik CLI, and should be created as a draft pull request as soon as one starts working on an issue. It shall stay as a draft until it is ready for review. All developers should aspire to keep pull requests small, but plenty.
When a PR has been merged, the PR branch should be deleted to keep the repository free of stale branches.

## Code Reviews

We use Code Reviews to review and approve code changes to the `staging` branch. Every pull request needs a code review to be merged, and everyone can perform a code review.

## Continuous Integration

We use Continuous Integration through Github Actions to perform lint checks, run tests, build software and perform static validations on the code before we merge into `staging` or `production`. A branch shall only be merged when all checks have passed.

## Continuous Deployment

We use Continous Deployment through Github Actions to deploy our code to its respective platforms. This happens whenever code is merged into `staging` or `production`.

> Exception: Our Next.js projects have their deployment automatically managed by Vercel.

## Commits and Commit Messages
We aspire to keep commits small and plenty. They should only contain relevant hunks and their commit message should accurately describe the change that the hunk implements. We do not squash our commits due to potential merge conflicts.

## Merge Conflicts

We resolve merge conflicts and test our code after again before requesting code review. We recommend resolving merge conflicts locally and not using GitHub's web interface.

## 2-factor authentication

We use 2-factor authentication for our GitHub accounts. We recommend [connecting SSH keys to your Github account](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh).

## Forecast Integration

All projects should have the Forecast integration enabled. It can be enabled on the forecast project under "Settings".

## Branch rules

Each repository should have the following branch rules:
For branches matching `/staging/`:

- Require pull request reviews before merging
- Require status checks to pass before merging
- Require branches to be up to date before merging (note that this requires a status check to be enabled)

For branches matching `/production/`:

- Require pull request reviews before merging
- Require status checks to pass before merging
- Require branches to be up to date before merging (note that this requires a status check to be enabled)
